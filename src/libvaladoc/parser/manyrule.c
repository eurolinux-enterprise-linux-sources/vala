/* manyrule.c generated by valac, the Vala compiler
 * generated from manyrule.vala, do not modify */

/* manyrule.vala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */


#include <glib.h>
#include <glib-object.h>
#include "valadoc.h"
#include <stdlib.h>
#include <string.h>


#define VALADOC_TYPE_MANY_RULE (valadoc_many_rule_get_type ())
#define VALADOC_MANY_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_MANY_RULE, ValadocManyRule))
#define VALADOC_MANY_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_MANY_RULE, ValadocManyRuleClass))
#define VALADOC_IS_MANY_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_MANY_RULE))
#define VALADOC_IS_MANY_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_MANY_RULE))
#define VALADOC_MANY_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_MANY_RULE, ValadocManyRuleClass))

typedef struct _ValadocManyRule ValadocManyRule;
typedef struct _ValadocManyRuleClass ValadocManyRuleClass;
typedef struct _ValadocManyRulePrivate ValadocManyRulePrivate;
enum  {
	VALADOC_MANY_RULE_0_PROPERTY,
	VALADOC_MANY_RULE_NUM_PROPERTIES
};
static GParamSpec* valadoc_many_rule_properties[VALADOC_MANY_RULE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define VALADOC_MANY_RULE_TYPE_STATE (valadoc_many_rule_state_get_type ())
#define VALADOC_MANY_RULE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_MANY_RULE_TYPE_STATE, ValadocManyRuleState))
#define VALADOC_MANY_RULE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_MANY_RULE_TYPE_STATE, ValadocManyRuleStateClass))
#define VALADOC_MANY_RULE_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_MANY_RULE_TYPE_STATE))
#define VALADOC_MANY_RULE_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_MANY_RULE_TYPE_STATE))
#define VALADOC_MANY_RULE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_MANY_RULE_TYPE_STATE, ValadocManyRuleStateClass))

typedef struct _ValadocManyRuleState ValadocManyRuleState;
typedef struct _ValadocManyRuleStateClass ValadocManyRuleStateClass;
typedef struct _ValadocManyRuleStatePrivate ValadocManyRuleStatePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
enum  {
	VALADOC_MANY_RULE_STATE_0_PROPERTY,
	VALADOC_MANY_RULE_STATE_NUM_PROPERTIES
};
static GParamSpec* valadoc_many_rule_state_properties[VALADOC_MANY_RULE_STATE_NUM_PROPERTIES];

struct _ValadocManyRule {
	ValadocRule parent_instance;
	ValadocManyRulePrivate * priv;
};

struct _ValadocManyRuleClass {
	ValadocRuleClass parent_class;
};

struct _ValadocManyRulePrivate {
	GObject* _scheme;
};

struct _ValadocManyRuleState {
	GObject parent_instance;
	gboolean started;
	gboolean done_one;
	ValadocManyRuleStatePrivate * priv;
};

struct _ValadocManyRuleStateClass {
	GObjectClass parent_class;
};


static gpointer valadoc_many_rule_parent_class = NULL;
static gpointer valadoc_many_rule_state_parent_class = NULL;

G_GNUC_INTERNAL GType valadoc_many_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define VALADOC_MANY_RULE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALADOC_TYPE_MANY_RULE, ValadocManyRulePrivate))
G_GNUC_INTERNAL ValadocManyRule* valadoc_many_rule_new (GObject* scheme);
G_GNUC_INTERNAL ValadocManyRule* valadoc_many_rule_construct (GType object_type,
                                              GObject* scheme);
static gboolean valadoc_many_rule_real_is_optional (ValadocRule* base);
static gboolean valadoc_many_rule_real_starts_with_token (ValadocRule* base,
                                                   ValadocToken* token);
static gboolean valadoc_many_rule_real_accept_token (ValadocRule* base,
                                              ValadocToken* token,
                                              ValadocParserCallback* parser,
                                              ValadocRuleForward forward,
                                              GError** error);
static GType valadoc_many_rule_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static ValadocManyRuleState* valadoc_many_rule_state_new (void);
static ValadocManyRuleState* valadoc_many_rule_state_construct (GType object_type);
static gboolean valadoc_many_rule_real_would_accept_token (ValadocRule* base,
                                                    ValadocToken* token,
                                                    GObject* state);
static gboolean valadoc_many_rule_real_would_reduce (ValadocRule* base,
                                              ValadocToken* token,
                                              GObject* rule_state);
static gchar* valadoc_many_rule_real_to_string (ValadocRule* base,
                                         GObject* rule_state);
static void valadoc_many_rule_state_finalize (GObject * obj);
static void valadoc_many_rule_finalize (GObject * obj);


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


G_GNUC_INTERNAL ValadocManyRule*
valadoc_many_rule_construct (GType object_type,
                             GObject* scheme)
{
	ValadocManyRule * self = NULL;
	GObject* _tmp0_;
	g_return_val_if_fail (scheme != NULL, NULL);
	self = (ValadocManyRule*) valadoc_rule_construct (object_type);
	_tmp0_ = _g_object_ref0 (scheme);
	_g_object_unref0 (self->priv->_scheme);
	self->priv->_scheme = _tmp0_;
	return self;
}


G_GNUC_INTERNAL ValadocManyRule*
valadoc_many_rule_new (GObject* scheme)
{
	return valadoc_many_rule_construct (VALADOC_TYPE_MANY_RULE, scheme);
}


static gboolean
valadoc_many_rule_real_is_optional (ValadocRule* base)
{
	ValadocManyRule * self;
	gboolean result = FALSE;
	GObject* _tmp0_;
	self = (ValadocManyRule*) base;
	_tmp0_ = self->priv->_scheme;
	result = valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp0_);
	return result;
}


static gboolean
valadoc_many_rule_real_starts_with_token (ValadocRule* base,
                                          ValadocToken* token)
{
	ValadocManyRule * self;
	gboolean result = FALSE;
	GObject* _tmp0_;
	self = (ValadocManyRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = self->priv->_scheme;
	if (valadoc_rule_has_start_token ((ValadocRule*) self, _tmp0_, token)) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean
valadoc_many_rule_real_accept_token (ValadocRule* base,
                                     ValadocToken* token,
                                     ValadocParserCallback* parser,
                                     ValadocRuleForward forward,
                                     GError** error)
{
	ValadocManyRule * self;
	gboolean result = FALSE;
	ValadocManyRuleState* state = NULL;
	GObject* _tmp0_;
	ValadocManyRuleState* _tmp1_;
	ValadocManyRuleState* _tmp2_;
	ValadocManyRuleState* _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp10_ = FALSE;
	ValadocManyRuleState* _tmp11_;
	gboolean _tmp12_;
	gboolean handled = FALSE;
	gboolean _tmp17_ = FALSE;
	GObject* _tmp18_;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_;
	GObject* _tmp26_;
	GError * _inner_error_ = NULL;
	self = (ValadocManyRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	g_return_val_if_fail (parser != NULL, FALSE);
	_tmp0_ = valadoc_parser_callback_get_rule_state (parser);
	_tmp1_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, VALADOC_MANY_RULE_TYPE_STATE) ? ((ValadocManyRuleState*) _tmp0_) : NULL;
	if (_tmp1_ == NULL) {
		_g_object_unref0 (_tmp0_);
	}
	state = _tmp1_;
	_tmp2_ = state;
	if (_tmp2_ == NULL) {
		ValadocManyRuleState* _tmp3_;
		ValadocManyRuleState* _tmp4_;
		_tmp3_ = valadoc_many_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp3_;
		_tmp4_ = state;
		valadoc_parser_callback_set_rule_state (parser, (GObject*) _tmp4_);
	}
	_tmp5_ = state;
	_tmp6_ = _tmp5_->started;
	if (!_tmp6_) {
		ValadocManyRuleState* _tmp9_;
		valadoc_rule_do_start ((ValadocRule*) self, parser, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp7_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp7_;
			} else {
				gboolean _tmp8_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp8_;
			}
		}
		_tmp9_ = state;
		_tmp9_->started = TRUE;
	}
	_tmp11_ = state;
	_tmp12_ = _tmp11_->done_one;
	if (_tmp12_) {
		_tmp10_ = valadoc_parser_callback_would_parent_accept_token (parser, token);
	} else {
		_tmp10_ = FALSE;
	}
	if (_tmp10_) {
		valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp13_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp13_;
			} else {
				gboolean _tmp14_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp14_;
			}
		}
		result = FALSE;
		_g_object_unref0 (state);
		return result;
	}
	if (valadoc_parser_callback_would_parent_reduce_to_rule (parser, token, (ValadocRule*) self)) {
		valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp15_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp15_;
			} else {
				gboolean _tmp16_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp16_;
			}
		}
		result = FALSE;
		_g_object_unref0 (state);
		return result;
	}
	_tmp18_ = self->priv->_scheme;
	_tmp20_ = valadoc_rule_try_to_apply ((ValadocRule*) self, _tmp18_, token, parser, &_tmp19_, &_inner_error_);
	handled = _tmp19_;
	_tmp17_ = _tmp20_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
			gboolean _tmp21_ = FALSE;
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (state);
			return _tmp21_;
		} else {
			gboolean _tmp22_ = FALSE;
			_g_object_unref0 (state);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp22_;
		}
	}
	if (_tmp17_) {
		ValadocManyRuleState* _tmp23_;
		_tmp23_ = state;
		_tmp23_->done_one = TRUE;
		result = handled;
		_g_object_unref0 (state);
		return result;
	}
	if (valadoc_parser_callback_would_parent_accept_token (parser, token)) {
		valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp24_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp24_;
			} else {
				gboolean _tmp25_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp25_;
			}
		}
		result = FALSE;
		_g_object_unref0 (state);
		return result;
	}
	_tmp26_ = self->priv->_scheme;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp26_, VALADOC_TYPE_TOKEN_TYPE)) {
		GObject* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_;
		gchar* _tmp30_;
		_tmp27_ = self->priv->_scheme;
		_tmp28_ = valadoc_token_type_to_pretty_string (G_TYPE_CHECK_INSTANCE_CAST (_tmp27_, VALADOC_TYPE_TOKEN_TYPE, ValadocTokenType));
		_tmp29_ = g_strdup_printf ("expected %s", _tmp28_);
		_tmp30_ = _tmp29_;
		valadoc_parser_callback_error (parser, NULL, _tmp30_, &_inner_error_);
		_g_free0 (_tmp30_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp31_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp31_;
			} else {
				gboolean _tmp32_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp32_;
			}
		}
	} else {
		valadoc_parser_callback_error (parser, token, "unexpected token", &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp33_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp33_;
			} else {
				gboolean _tmp34_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp34_;
			}
		}
	}
	g_assert_not_reached ();
	_g_object_unref0 (state);
}


static gboolean
valadoc_many_rule_real_would_accept_token (ValadocRule* base,
                                           ValadocToken* token,
                                           GObject* state)
{
	ValadocManyRule * self;
	gboolean result = FALSE;
	GObject* _tmp0_;
	self = (ValadocManyRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = self->priv->_scheme;
	if (valadoc_rule_has_start_token ((ValadocRule*) self, _tmp0_, token)) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean
valadoc_many_rule_real_would_reduce (ValadocRule* base,
                                     ValadocToken* token,
                                     GObject* rule_state)
{
	ValadocManyRule * self;
	gboolean result = FALSE;
	ValadocManyRuleState* state = NULL;
	ValadocManyRuleState* _tmp0_;
	gboolean _tmp1_ = FALSE;
	ValadocManyRuleState* _tmp2_;
	gboolean _tmp3_;
	self = (ValadocManyRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (rule_state, VALADOC_MANY_RULE_TYPE_STATE) ? ((ValadocManyRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp2_ = state;
	_tmp3_ = _tmp2_->done_one;
	if (_tmp3_) {
		_tmp1_ = TRUE;
	} else {
		GObject* _tmp4_;
		_tmp4_ = self->priv->_scheme;
		_tmp1_ = valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp4_);
	}
	result = _tmp1_;
	_g_object_unref0 (state);
	return result;
}


static gchar*
bool_to_string (gboolean self)
{
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


static gchar*
valadoc_many_rule_real_to_string (ValadocRule* base,
                                  GObject* rule_state)
{
	ValadocManyRule * self;
	gchar* result = NULL;
	ValadocManyRuleState* state = NULL;
	ValadocManyRuleState* _tmp0_;
	ValadocManyRuleState* _tmp1_;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	ValadocManyRuleState* _tmp8_;
	gboolean _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	ValadocManyRuleState* _tmp12_;
	gboolean _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	self = (ValadocManyRule*) base;
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (rule_state, VALADOC_MANY_RULE_TYPE_STATE) ? ((ValadocManyRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp1_ = state;
	if (_tmp1_ == NULL) {
		ValadocManyRuleState* _tmp2_;
		_tmp2_ = valadoc_many_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp2_;
	}
	_tmp4_ = valadoc_rule_get_name ((ValadocRule*) self);
	_tmp5_ = _tmp4_;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		_tmp6_ = valadoc_rule_get_name ((ValadocRule*) self);
		_tmp7_ = _tmp6_;
		_tmp3_ = _tmp7_;
	} else {
		_tmp3_ = " ";
	}
	_tmp8_ = state;
	_tmp9_ = _tmp8_->started;
	_tmp10_ = bool_to_string (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = state;
	_tmp13_ = _tmp12_->done_one;
	_tmp14_ = bool_to_string (_tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = g_strdup_printf ("%-15s%-15s(started=%s;done_one=%s)", _tmp3_, "[many]", _tmp11_, _tmp15_);
	_tmp17_ = _tmp16_;
	_g_free0 (_tmp15_);
	_g_free0 (_tmp11_);
	result = _tmp17_;
	_g_object_unref0 (state);
	return result;
}


static ValadocManyRuleState*
valadoc_many_rule_state_construct (GType object_type)
{
	ValadocManyRuleState * self = NULL;
	self = (ValadocManyRuleState*) g_object_new (object_type, NULL);
	return self;
}


static ValadocManyRuleState*
valadoc_many_rule_state_new (void)
{
	return valadoc_many_rule_state_construct (VALADOC_MANY_RULE_TYPE_STATE);
}


static void
valadoc_many_rule_state_class_init (ValadocManyRuleStateClass * klass)
{
	valadoc_many_rule_state_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = valadoc_many_rule_state_finalize;
}


static void
valadoc_many_rule_state_instance_init (ValadocManyRuleState * self)
{
	self->started = FALSE;
	self->done_one = FALSE;
}


static void
valadoc_many_rule_state_finalize (GObject * obj)
{
	ValadocManyRuleState * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_MANY_RULE_TYPE_STATE, ValadocManyRuleState);
	G_OBJECT_CLASS (valadoc_many_rule_state_parent_class)->finalize (obj);
}


static GType
valadoc_many_rule_state_get_type (void)
{
	static volatile gsize valadoc_many_rule_state_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_many_rule_state_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocManyRuleStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_many_rule_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocManyRuleState), 0, (GInstanceInitFunc) valadoc_many_rule_state_instance_init, NULL };
		GType valadoc_many_rule_state_type_id;
		valadoc_many_rule_state_type_id = g_type_register_static (G_TYPE_OBJECT, "ValadocManyRuleState", &g_define_type_info, 0);
		g_once_init_leave (&valadoc_many_rule_state_type_id__volatile, valadoc_many_rule_state_type_id);
	}
	return valadoc_many_rule_state_type_id__volatile;
}


static void
valadoc_many_rule_class_init (ValadocManyRuleClass * klass)
{
	valadoc_many_rule_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ValadocManyRulePrivate));
	((ValadocRuleClass *) klass)->is_optional = (gboolean (*) (ValadocRule *)) valadoc_many_rule_real_is_optional;
	((ValadocRuleClass *) klass)->starts_with_token = (gboolean (*) (ValadocRule *, ValadocToken*)) valadoc_many_rule_real_starts_with_token;
	((ValadocRuleClass *) klass)->accept_token = (gboolean (*) (ValadocRule *, ValadocToken*, ValadocParserCallback*, ValadocRuleForward, GError**)) valadoc_many_rule_real_accept_token;
	((ValadocRuleClass *) klass)->would_accept_token = (gboolean (*) (ValadocRule *, ValadocToken*, GObject*)) valadoc_many_rule_real_would_accept_token;
	((ValadocRuleClass *) klass)->would_reduce = (gboolean (*) (ValadocRule *, ValadocToken*, GObject*)) valadoc_many_rule_real_would_reduce;
	((ValadocRuleClass *) klass)->to_string = (gchar* (*) (ValadocRule *, GObject*)) valadoc_many_rule_real_to_string;
	G_OBJECT_CLASS (klass)->finalize = valadoc_many_rule_finalize;
}


static void
valadoc_many_rule_instance_init (ValadocManyRule * self)
{
	self->priv = VALADOC_MANY_RULE_GET_PRIVATE (self);
}


static void
valadoc_many_rule_finalize (GObject * obj)
{
	ValadocManyRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_TYPE_MANY_RULE, ValadocManyRule);
	_g_object_unref0 (self->priv->_scheme);
	G_OBJECT_CLASS (valadoc_many_rule_parent_class)->finalize (obj);
}


G_GNUC_INTERNAL GType
valadoc_many_rule_get_type (void)
{
	static volatile gsize valadoc_many_rule_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_many_rule_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocManyRuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_many_rule_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocManyRule), 0, (GInstanceInitFunc) valadoc_many_rule_instance_init, NULL };
		GType valadoc_many_rule_type_id;
		valadoc_many_rule_type_id = g_type_register_static (VALADOC_TYPE_RULE, "ValadocManyRule", &g_define_type_info, 0);
		g_once_init_leave (&valadoc_many_rule_type_id__volatile, valadoc_many_rule_type_id);
	}
	return valadoc_many_rule_type_id__volatile;
}



