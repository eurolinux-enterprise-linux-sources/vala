/* sequencerule.c generated by valac, the Vala compiler
 * generated from sequencerule.vala, do not modify */

/* sequencerule.vala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */


#include <glib.h>
#include <glib-object.h>
#include "valadoc.h"
#include <stdlib.h>
#include <string.h>


#define VALADOC_TYPE_SEQUENCE_RULE (valadoc_sequence_rule_get_type ())
#define VALADOC_SEQUENCE_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRule))
#define VALADOC_SEQUENCE_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRuleClass))
#define VALADOC_IS_SEQUENCE_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_TYPE_SEQUENCE_RULE))
#define VALADOC_IS_SEQUENCE_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_TYPE_SEQUENCE_RULE))
#define VALADOC_SEQUENCE_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRuleClass))

typedef struct _ValadocSequenceRule ValadocSequenceRule;
typedef struct _ValadocSequenceRuleClass ValadocSequenceRuleClass;
typedef struct _ValadocSequenceRulePrivate ValadocSequenceRulePrivate;
enum  {
	VALADOC_SEQUENCE_RULE_0_PROPERTY,
	VALADOC_SEQUENCE_RULE_NUM_PROPERTIES
};
static GParamSpec* valadoc_sequence_rule_properties[VALADOC_SEQUENCE_RULE_NUM_PROPERTIES];

#define VALADOC_SEQUENCE_RULE_TYPE_STATE (valadoc_sequence_rule_state_get_type ())
#define VALADOC_SEQUENCE_RULE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleState))
#define VALADOC_SEQUENCE_RULE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleStateClass))
#define VALADOC_SEQUENCE_RULE_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALADOC_SEQUENCE_RULE_TYPE_STATE))
#define VALADOC_SEQUENCE_RULE_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALADOC_SEQUENCE_RULE_TYPE_STATE))
#define VALADOC_SEQUENCE_RULE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleStateClass))

typedef struct _ValadocSequenceRuleState ValadocSequenceRuleState;
typedef struct _ValadocSequenceRuleStateClass ValadocSequenceRuleStateClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ValadocSequenceRuleStatePrivate ValadocSequenceRuleStatePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
enum  {
	VALADOC_SEQUENCE_RULE_STATE_0_PROPERTY,
	VALADOC_SEQUENCE_RULE_STATE_NUM_PROPERTIES
};
static GParamSpec* valadoc_sequence_rule_state_properties[VALADOC_SEQUENCE_RULE_STATE_NUM_PROPERTIES];

struct _ValadocSequenceRule {
	ValadocRule parent_instance;
	ValadocSequenceRulePrivate * priv;
};

struct _ValadocSequenceRuleClass {
	ValadocRuleClass parent_class;
};

struct _ValadocSequenceRulePrivate {
	GObject** _scheme;
	gint _scheme_length1;
	gint __scheme_size_;
};

struct _ValadocSequenceRuleState {
	GObject parent_instance;
	gint index;
	ValadocSequenceRuleStatePrivate * priv;
};

struct _ValadocSequenceRuleStateClass {
	GObjectClass parent_class;
};


static gpointer valadoc_sequence_rule_parent_class = NULL;
static gpointer valadoc_sequence_rule_state_parent_class = NULL;

G_GNUC_INTERNAL GType valadoc_sequence_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define VALADOC_SEQUENCE_RULE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRulePrivate))
G_GNUC_INTERNAL ValadocSequenceRule* valadoc_sequence_rule_new (GObject** scheme,
                                                int scheme_length1);
G_GNUC_INTERNAL ValadocSequenceRule* valadoc_sequence_rule_construct (GType object_type,
                                                      GObject** scheme,
                                                      int scheme_length1);
static GObject** _vala_array_dup3 (GObject** self,
                            int length);
static gboolean valadoc_sequence_rule_real_is_optional (ValadocRule* base);
static gboolean valadoc_sequence_rule_real_starts_with_token (ValadocRule* base,
                                                       ValadocToken* token);
static gboolean valadoc_sequence_rule_test_token (ValadocSequenceRule* self,
                                           gint from_index,
                                           ValadocToken* token);
static gboolean valadoc_sequence_rule_test_reduce (ValadocSequenceRule* self,
                                            gint from_index,
                                            ValadocToken* token);
static gboolean valadoc_sequence_rule_real_accept_token (ValadocRule* base,
                                                  ValadocToken* token,
                                                  ValadocParserCallback* parser,
                                                  ValadocRuleForward forward,
                                                  GError** error);
static GType valadoc_sequence_rule_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static ValadocSequenceRuleState* valadoc_sequence_rule_state_new (void);
static ValadocSequenceRuleState* valadoc_sequence_rule_state_construct (GType object_type);
static gboolean valadoc_sequence_rule_real_would_accept_token (ValadocRule* base,
                                                        ValadocToken* token,
                                                        GObject* rule_state);
static gboolean valadoc_sequence_rule_real_would_reduce (ValadocRule* base,
                                                  ValadocToken* token,
                                                  GObject* rule_state);
static gchar* valadoc_sequence_rule_real_to_string (ValadocRule* base,
                                             GObject* rule_state);
static void valadoc_sequence_rule_state_finalize (GObject * obj);
static void valadoc_sequence_rule_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static GObject**
_vala_array_dup3 (GObject** self,
                  int length)
{
	GObject** result;
	int i;
	result = g_new0 (GObject*, length + 1);
	for (i = 0; i < length; i++) {
		GObject* _tmp0_;
		_tmp0_ = _g_object_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


G_GNUC_INTERNAL ValadocSequenceRule*
valadoc_sequence_rule_construct (GType object_type,
                                 GObject** scheme,
                                 int scheme_length1)
{
	ValadocSequenceRule * self = NULL;
	GObject** _tmp0_;
	gint _tmp0__length1;
	self = (ValadocSequenceRule*) valadoc_rule_construct (object_type);
	_tmp0_ = (scheme != NULL) ? _vala_array_dup3 (scheme, scheme_length1) : ((gpointer) scheme);
	_tmp0__length1 = scheme_length1;
	self->priv->_scheme = (_vala_array_free (self->priv->_scheme, self->priv->_scheme_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->_scheme = _tmp0_;
	self->priv->_scheme_length1 = _tmp0__length1;
	self->priv->__scheme_size_ = self->priv->_scheme_length1;
	return self;
}


G_GNUC_INTERNAL ValadocSequenceRule*
valadoc_sequence_rule_new (GObject** scheme,
                           int scheme_length1)
{
	return valadoc_sequence_rule_construct (VALADOC_TYPE_SEQUENCE_RULE, scheme, scheme_length1);
}


static gboolean
valadoc_sequence_rule_real_is_optional (ValadocRule* base)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	result = FALSE;
	return result;
}


static gboolean
valadoc_sequence_rule_real_starts_with_token (ValadocRule* base,
                                              ValadocToken* token)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	result = valadoc_sequence_rule_test_token (self, 0, token);
	return result;
}


static gboolean
valadoc_sequence_rule_test_token (ValadocSequenceRule* self,
                                  gint from_index,
                                  ValadocToken* token)
{
	gboolean result = FALSE;
	gint i = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (token != NULL, FALSE);
	i = from_index;
	while (TRUE) {
		gint _tmp0_;
		GObject** _tmp1_;
		gint _tmp1__length1;
		GObject** _tmp2_;
		gint _tmp2__length1;
		gint _tmp3_;
		GObject* _tmp4_;
		GObject** _tmp5_;
		gint _tmp5__length1;
		gint _tmp6_;
		GObject* _tmp7_;
		gint _tmp8_;
		_tmp0_ = i;
		_tmp1_ = self->priv->_scheme;
		_tmp1__length1 = self->priv->_scheme_length1;
		if (!(_tmp0_ < _tmp1__length1)) {
			break;
		}
		_tmp2_ = self->priv->_scheme;
		_tmp2__length1 = self->priv->_scheme_length1;
		_tmp3_ = i;
		_tmp4_ = _tmp2_[_tmp3_];
		if (valadoc_rule_has_start_token ((ValadocRule*) self, _tmp4_, token)) {
			result = TRUE;
			return result;
		}
		_tmp5_ = self->priv->_scheme;
		_tmp5__length1 = self->priv->_scheme_length1;
		_tmp6_ = i;
		_tmp7_ = _tmp5_[_tmp6_];
		if (!valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp7_)) {
			break;
		}
		_tmp8_ = i;
		i = _tmp8_ + 1;
	}
	result = FALSE;
	return result;
}


static gboolean
valadoc_sequence_rule_test_reduce (ValadocSequenceRule* self,
                                   gint from_index,
                                   ValadocToken* token)
{
	gboolean result = FALSE;
	gint i = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (token != NULL, FALSE);
	i = from_index;
	while (TRUE) {
		gint _tmp0_;
		GObject** _tmp1_;
		gint _tmp1__length1;
		GObject** _tmp2_;
		gint _tmp2__length1;
		gint _tmp3_;
		GObject* _tmp4_;
		gint _tmp5_;
		_tmp0_ = i;
		_tmp1_ = self->priv->_scheme;
		_tmp1__length1 = self->priv->_scheme_length1;
		if (!(_tmp0_ < _tmp1__length1)) {
			break;
		}
		_tmp2_ = self->priv->_scheme;
		_tmp2__length1 = self->priv->_scheme_length1;
		_tmp3_ = i;
		_tmp4_ = _tmp2_[_tmp3_];
		if (!valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp4_)) {
			result = FALSE;
			return result;
		}
		_tmp5_ = i;
		i = _tmp5_ + 1;
	}
	result = TRUE;
	return result;
}


static gboolean
valadoc_sequence_rule_real_accept_token (ValadocRule* base,
                                         ValadocToken* token,
                                         ValadocParserCallback* parser,
                                         ValadocRuleForward forward,
                                         GError** error)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	ValadocSequenceRuleState* state = NULL;
	GObject* _tmp0_;
	ValadocSequenceRuleState* _tmp1_;
	ValadocSequenceRuleState* _tmp2_;
	ValadocSequenceRuleState* _tmp5_;
	gint _tmp6_;
	GObject* scheme_element = NULL;
	gboolean handled = FALSE;
	ValadocSequenceRuleState* _tmp37_;
	gint _tmp38_;
	GObject** _tmp39_;
	gint _tmp39__length1;
	GObject* _tmp42_;
	GError * _inner_error_ = NULL;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	g_return_val_if_fail (parser != NULL, FALSE);
	_tmp0_ = valadoc_parser_callback_get_rule_state (parser);
	_tmp1_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, VALADOC_SEQUENCE_RULE_TYPE_STATE) ? ((ValadocSequenceRuleState*) _tmp0_) : NULL;
	if (_tmp1_ == NULL) {
		_g_object_unref0 (_tmp0_);
	}
	state = _tmp1_;
	_tmp2_ = state;
	if (_tmp2_ == NULL) {
		ValadocSequenceRuleState* _tmp3_;
		ValadocSequenceRuleState* _tmp4_;
		_tmp3_ = valadoc_sequence_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp3_;
		_tmp4_ = state;
		valadoc_parser_callback_set_rule_state (parser, (GObject*) _tmp4_);
	}
	_tmp5_ = state;
	_tmp6_ = _tmp5_->index;
	if (_tmp6_ == 0) {
		valadoc_rule_do_start ((ValadocRule*) self, parser, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp7_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (state);
				return _tmp7_;
			} else {
				gboolean _tmp8_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp8_;
			}
		}
	} else {
		ValadocSequenceRuleState* _tmp9_;
		gint _tmp10_;
		GObject** _tmp11_;
		gint _tmp11__length1;
		_tmp9_ = state;
		_tmp10_ = _tmp9_->index;
		_tmp11_ = self->priv->_scheme;
		_tmp11__length1 = self->priv->_scheme_length1;
		if (_tmp10_ == _tmp11__length1) {
			valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
					gboolean _tmp12_ = FALSE;
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (state);
					return _tmp12_;
				} else {
					gboolean _tmp13_ = FALSE;
					_g_object_unref0 (state);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return _tmp13_;
				}
			}
			result = FALSE;
			_g_object_unref0 (state);
			return result;
		}
	}
	scheme_element = NULL;
	{
		gboolean _tmp14_ = FALSE;
		_tmp14_ = TRUE;
		while (TRUE) {
			GObject** _tmp18_;
			gint _tmp18__length1;
			ValadocSequenceRuleState* _tmp19_;
			gint _tmp20_;
			GObject* _tmp21_;
			GObject* _tmp22_;
			gboolean _tmp23_ = FALSE;
			GObject* _tmp24_;
			gboolean _tmp25_ = FALSE;
			gboolean _tmp26_;
			GObject* _tmp31_;
			ValadocSequenceRuleState* _tmp35_;
			gint _tmp36_;
			if (!_tmp14_) {
				ValadocSequenceRuleState* _tmp15_;
				gint _tmp16_;
				GObject** _tmp17_;
				gint _tmp17__length1;
				_tmp15_ = state;
				_tmp16_ = _tmp15_->index;
				_tmp17_ = self->priv->_scheme;
				_tmp17__length1 = self->priv->_scheme_length1;
				if (!(_tmp16_ < _tmp17__length1)) {
					break;
				}
			}
			_tmp14_ = FALSE;
			_tmp18_ = self->priv->_scheme;
			_tmp18__length1 = self->priv->_scheme_length1;
			_tmp19_ = state;
			_tmp20_ = _tmp19_->index;
			_tmp21_ = _tmp18_[_tmp20_];
			_tmp22_ = _g_object_ref0 (_tmp21_);
			_g_object_unref0 (scheme_element);
			scheme_element = _tmp22_;
			_tmp24_ = scheme_element;
			_tmp26_ = valadoc_rule_try_to_apply ((ValadocRule*) self, _tmp24_, token, parser, &_tmp25_, &_inner_error_);
			handled = _tmp25_;
			_tmp23_ = _tmp26_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
					gboolean _tmp27_ = FALSE;
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (scheme_element);
					_g_object_unref0 (state);
					return _tmp27_;
				} else {
					gboolean _tmp28_ = FALSE;
					_g_object_unref0 (scheme_element);
					_g_object_unref0 (state);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return _tmp28_;
				}
			}
			if (_tmp23_) {
				ValadocSequenceRuleState* _tmp29_;
				gint _tmp30_;
				_tmp29_ = state;
				_tmp30_ = _tmp29_->index;
				_tmp29_->index = _tmp30_ + 1;
				result = handled;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return result;
			}
			_tmp31_ = scheme_element;
			if (!valadoc_rule_is_optional_rule ((ValadocRule*) self, _tmp31_)) {
				break;
			} else {
				GObject* _tmp32_;
				_tmp32_ = scheme_element;
				valadoc_rule_do_skip (G_TYPE_CHECK_INSTANCE_CAST (_tmp32_, VALADOC_TYPE_RULE, ValadocRule), parser, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
						gboolean _tmp33_ = FALSE;
						g_propagate_error (error, _inner_error_);
						_g_object_unref0 (scheme_element);
						_g_object_unref0 (state);
						return _tmp33_;
					} else {
						gboolean _tmp34_ = FALSE;
						_g_object_unref0 (scheme_element);
						_g_object_unref0 (state);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return _tmp34_;
					}
				}
			}
			_tmp35_ = state;
			_tmp36_ = _tmp35_->index;
			_tmp35_->index = _tmp36_ + 1;
		}
	}
	_tmp37_ = state;
	_tmp38_ = _tmp37_->index;
	_tmp39_ = self->priv->_scheme;
	_tmp39__length1 = self->priv->_scheme_length1;
	if (_tmp38_ == _tmp39__length1) {
		valadoc_rule_do_reduce ((ValadocRule*) self, parser, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp40_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return _tmp40_;
			} else {
				gboolean _tmp41_ = FALSE;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp41_;
			}
		}
		result = FALSE;
		_g_object_unref0 (scheme_element);
		_g_object_unref0 (state);
		return result;
	}
	_tmp42_ = scheme_element;
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp42_, VALADOC_TYPE_TOKEN_TYPE)) {
		GObject* _tmp43_;
		const gchar* _tmp44_;
		gchar* _tmp45_;
		gchar* _tmp46_;
		_tmp43_ = scheme_element;
		_tmp44_ = valadoc_token_type_to_pretty_string (G_TYPE_CHECK_INSTANCE_CAST (_tmp43_, VALADOC_TYPE_TOKEN_TYPE, ValadocTokenType));
		_tmp45_ = g_strdup_printf ("expected %s", _tmp44_);
		_tmp46_ = _tmp45_;
		valadoc_parser_callback_error (parser, token, _tmp46_, &_inner_error_);
		_g_free0 (_tmp46_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp47_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return _tmp47_;
			} else {
				gboolean _tmp48_ = FALSE;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp48_;
			}
		}
	} else {
		valadoc_parser_callback_error (parser, token, "unexpected token", &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == VALADOC_PARSER_ERROR) {
				gboolean _tmp49_ = FALSE;
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				return _tmp49_;
			} else {
				gboolean _tmp50_ = FALSE;
				_g_object_unref0 (scheme_element);
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return _tmp50_;
			}
		}
	}
	g_assert_not_reached ();
	_g_object_unref0 (scheme_element);
	_g_object_unref0 (state);
}


static gboolean
valadoc_sequence_rule_real_would_accept_token (ValadocRule* base,
                                               ValadocToken* token,
                                               GObject* rule_state)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	ValadocSequenceRuleState* state = NULL;
	ValadocSequenceRuleState* _tmp0_;
	gint _tmp1_;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (rule_state, VALADOC_SEQUENCE_RULE_TYPE_STATE) ? ((ValadocSequenceRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp1_ = state->index;
	result = valadoc_sequence_rule_test_token (self, _tmp1_, token);
	_g_object_unref0 (state);
	return result;
}


static gboolean
valadoc_sequence_rule_real_would_reduce (ValadocRule* base,
                                         ValadocToken* token,
                                         GObject* rule_state)
{
	ValadocSequenceRule * self;
	gboolean result = FALSE;
	ValadocSequenceRuleState* state = NULL;
	ValadocSequenceRuleState* _tmp0_;
	gboolean _tmp1_ = FALSE;
	ValadocSequenceRuleState* _tmp2_;
	gint _tmp3_;
	GObject** _tmp4_;
	gint _tmp4__length1;
	self = (ValadocSequenceRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (rule_state, VALADOC_SEQUENCE_RULE_TYPE_STATE) ? ((ValadocSequenceRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp2_ = state;
	_tmp3_ = _tmp2_->index;
	_tmp4_ = self->priv->_scheme;
	_tmp4__length1 = self->priv->_scheme_length1;
	if (_tmp3_ == _tmp4__length1) {
		_tmp1_ = TRUE;
	} else {
		ValadocSequenceRuleState* _tmp5_;
		gint _tmp6_;
		_tmp5_ = state;
		_tmp6_ = _tmp5_->index;
		_tmp1_ = valadoc_sequence_rule_test_reduce (self, _tmp6_, token);
	}
	result = _tmp1_;
	_g_object_unref0 (state);
	return result;
}


static gchar*
valadoc_sequence_rule_real_to_string (ValadocRule* base,
                                      GObject* rule_state)
{
	ValadocSequenceRule * self;
	gchar* result = NULL;
	ValadocSequenceRuleState* state = NULL;
	ValadocSequenceRuleState* _tmp0_;
	ValadocSequenceRuleState* _tmp1_;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	ValadocSequenceRuleState* _tmp8_;
	gint _tmp9_;
	GObject** _tmp10_;
	gint _tmp10__length1;
	gchar* _tmp11_;
	self = (ValadocSequenceRule*) base;
	_tmp0_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (rule_state, VALADOC_SEQUENCE_RULE_TYPE_STATE) ? ((ValadocSequenceRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp1_ = state;
	if (_tmp1_ == NULL) {
		ValadocSequenceRuleState* _tmp2_;
		_tmp2_ = valadoc_sequence_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp2_;
	}
	_tmp4_ = valadoc_rule_get_name ((ValadocRule*) self);
	_tmp5_ = _tmp4_;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		_tmp6_ = valadoc_rule_get_name ((ValadocRule*) self);
		_tmp7_ = _tmp6_;
		_tmp3_ = _tmp7_;
	} else {
		_tmp3_ = " ";
	}
	_tmp8_ = state;
	_tmp9_ = _tmp8_->index;
	_tmp10_ = self->priv->_scheme;
	_tmp10__length1 = self->priv->_scheme_length1;
	_tmp11_ = g_strdup_printf ("%-15s%-15s(index=%d/%d)", _tmp3_, "[seq]", _tmp9_, _tmp10__length1);
	result = _tmp11_;
	_g_object_unref0 (state);
	return result;
}


static ValadocSequenceRuleState*
valadoc_sequence_rule_state_construct (GType object_type)
{
	ValadocSequenceRuleState * self = NULL;
	self = (ValadocSequenceRuleState*) g_object_new (object_type, NULL);
	return self;
}


static ValadocSequenceRuleState*
valadoc_sequence_rule_state_new (void)
{
	return valadoc_sequence_rule_state_construct (VALADOC_SEQUENCE_RULE_TYPE_STATE);
}


static void
valadoc_sequence_rule_state_class_init (ValadocSequenceRuleStateClass * klass)
{
	valadoc_sequence_rule_state_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = valadoc_sequence_rule_state_finalize;
}


static void
valadoc_sequence_rule_state_instance_init (ValadocSequenceRuleState * self)
{
	self->index = 0;
}


static void
valadoc_sequence_rule_state_finalize (GObject * obj)
{
	ValadocSequenceRuleState * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_SEQUENCE_RULE_TYPE_STATE, ValadocSequenceRuleState);
	G_OBJECT_CLASS (valadoc_sequence_rule_state_parent_class)->finalize (obj);
}


static GType
valadoc_sequence_rule_state_get_type (void)
{
	static volatile gsize valadoc_sequence_rule_state_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_sequence_rule_state_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocSequenceRuleStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_sequence_rule_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocSequenceRuleState), 0, (GInstanceInitFunc) valadoc_sequence_rule_state_instance_init, NULL };
		GType valadoc_sequence_rule_state_type_id;
		valadoc_sequence_rule_state_type_id = g_type_register_static (G_TYPE_OBJECT, "ValadocSequenceRuleState", &g_define_type_info, 0);
		g_once_init_leave (&valadoc_sequence_rule_state_type_id__volatile, valadoc_sequence_rule_state_type_id);
	}
	return valadoc_sequence_rule_state_type_id__volatile;
}


static void
valadoc_sequence_rule_class_init (ValadocSequenceRuleClass * klass)
{
	valadoc_sequence_rule_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ValadocSequenceRulePrivate));
	((ValadocRuleClass *) klass)->is_optional = (gboolean (*) (ValadocRule *)) valadoc_sequence_rule_real_is_optional;
	((ValadocRuleClass *) klass)->starts_with_token = (gboolean (*) (ValadocRule *, ValadocToken*)) valadoc_sequence_rule_real_starts_with_token;
	((ValadocRuleClass *) klass)->accept_token = (gboolean (*) (ValadocRule *, ValadocToken*, ValadocParserCallback*, ValadocRuleForward, GError**)) valadoc_sequence_rule_real_accept_token;
	((ValadocRuleClass *) klass)->would_accept_token = (gboolean (*) (ValadocRule *, ValadocToken*, GObject*)) valadoc_sequence_rule_real_would_accept_token;
	((ValadocRuleClass *) klass)->would_reduce = (gboolean (*) (ValadocRule *, ValadocToken*, GObject*)) valadoc_sequence_rule_real_would_reduce;
	((ValadocRuleClass *) klass)->to_string = (gchar* (*) (ValadocRule *, GObject*)) valadoc_sequence_rule_real_to_string;
	G_OBJECT_CLASS (klass)->finalize = valadoc_sequence_rule_finalize;
}


static void
valadoc_sequence_rule_instance_init (ValadocSequenceRule * self)
{
	self->priv = VALADOC_SEQUENCE_RULE_GET_PRIVATE (self);
}


static void
valadoc_sequence_rule_finalize (GObject * obj)
{
	ValadocSequenceRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, VALADOC_TYPE_SEQUENCE_RULE, ValadocSequenceRule);
	self->priv->_scheme = (_vala_array_free (self->priv->_scheme, self->priv->_scheme_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (valadoc_sequence_rule_parent_class)->finalize (obj);
}


G_GNUC_INTERNAL GType
valadoc_sequence_rule_get_type (void)
{
	static volatile gsize valadoc_sequence_rule_type_id__volatile = 0;
	if (g_once_init_enter (&valadoc_sequence_rule_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadocSequenceRuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valadoc_sequence_rule_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValadocSequenceRule), 0, (GInstanceInitFunc) valadoc_sequence_rule_instance_init, NULL };
		GType valadoc_sequence_rule_type_id;
		valadoc_sequence_rule_type_id = g_type_register_static (VALADOC_TYPE_RULE, "ValadocSequenceRule", &g_define_type_info, 0);
		g_once_init_leave (&valadoc_sequence_rule_type_id__volatile, valadoc_sequence_rule_type_id);
	}
	return valadoc_sequence_rule_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



